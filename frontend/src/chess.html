<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess - MindPlay Arena</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --light-square: #EEEED2;
            --dark-square: #769656;
            --selected-square: #BBCB44;
            --valid-move: #F7F769;
            --valid-move-dot: rgba(0, 0, 0, 0.2);
            --board-border: #604E37;
            --bg-color: #302E2B;
            --text-color: #E8E8E8;
            --highlight-color: #7FA650;
            --panel-bg: rgba(42, 40, 38, 0.8);
            --check-square: #FF6B6B;
            --checkmate-square: #FF0000;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: auto;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: var(--panel-bg);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-button:hover {
            background: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .back-button i {
            font-size: 16px;
        }

        h1 {
            color: var(--highlight-color);
            font-weight: 600;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .welcome-message {
            text-align: center;
            margin: 50px auto;
            padding: 30px;
            background: var(--panel-bg);
            border-radius: 15px;
            max-width: 600px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .welcome-message h2 {
            color: var(--highlight-color);
            margin-bottom: 20px;
            font-size: 1.8rem;
            font-weight: 500;
        }

        .welcome-message p {
            font-size: 18px;
            line-height: 1.6;
        }

        .hidden {
            display: none;
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin: 20px auto;
            width: 100%;
            max-width: 900px;
            transition: all 0.3s ease;
        }

        #chess-board {
            display: grid;
            grid-template-columns: repeat(8, 62.5px);
            grid-template-rows: repeat(8, 62.5px);
            width: 500px;
            margin: 20px auto;
            border: 12px solid var(--board-border);
            border-radius: 4px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
            position: relative;
        }

        /* Rank and file labels */
        .coordinate-label {
            position: absolute;
            font-size: 12px;
            color: var(--text-color);
            opacity: 0.75;
            font-weight: 600;
        }

        .file-label {
            bottom: -25px;
            text-align: center;
            width: 62.5px;
        }

        .rank-label {
            right: -25px;
            height: 62.5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .square {
            width: 62.5px;
            height: 62.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .square img {
            width: 52px;
            height: 52px;
            object-fit: contain;
            transition: transform 0.2s ease;
            z-index: 2;
        }

        .square:hover img {
            transform: scale(1.08);
            cursor: pointer;
        }

        .light {
            background-color: var(--light-square);
        }

        .dark {
            background-color: var(--dark-square);
        }

        .square.selected {
            background-color: var(--selected-square);
        }
        
        .square.valid-move {
            position: relative;
            cursor: pointer;
        }
        
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background-color: var(--valid-move-dot);
            border-radius: 50%;
            z-index: 1;
        }

        .square.valid-move.has-piece::after {
            width: 62.5px;
            height: 62.5px;
            border-radius: 0;
            background-color: rgba(255, 0, 0, 0.15);
            border: 3px solid rgba(255, 0, 0, 0.3);
            box-sizing: border-box;
        }

        .player-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: var(--panel-bg);
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-name {
            font-weight: 600;
            font-size: 16px;
        }

        .player-time {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 18px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .turn-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #e74c3c;
            margin-right: 10px;
        }

        .turn-active {
            background-color: #2ecc71;
            box-shadow: 0 0 8px #2ecc71;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            width: 120px;
            min-width: 120px;
        }

        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 15px;
            background: var(--panel-bg);
            border-radius: 8px;
            min-height: 100px;
            margin-bottom: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .captured-piece {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .captured-piece img {
            width: 25px;
            height: 25px;
            object-fit: contain;
        }

        #controls {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        button {
            padding: 12px 24px;
            margin: 5px;
            background: var(--highlight-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            font-size: 16px;
        }

        button:hover {
            background: #8EB95E;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #exit-game {
            background-color: #e74c3c;
        }

        #exit-game:hover {
            background-color: #c0392b;
        }

        #game-status {
            padding: 12px;
            background: var(--panel-bg);
            border-radius: 8px;
            margin: 15px auto;
            font-weight: 500;
            max-width: 500px;
        }

        /* Animation for moves */
        @keyframes movePiece {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .animate-move {
            animation: movePiece 0.3s ease-in-out;
        }

        /* Responsive adjustments */
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .side-panel {
                width: 100%;
                max-width: 500px;
                flex-direction: row;
                justify-content: space-between;
            }
            
            .captured-pieces {
                width: 48%;
            }
        }

        @media (max-width: 600px) {
            #chess-board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
                width: 320px;
                border-width: 8px;
            }
            
            .square {
                width: 40px;
                height: 40px;
            }
            
            .square img {
                width: 35px;
                height: 35px;
            }
            
            .file-label {
                width: 40px;
            }
            
            .rank-label {
                height: 40px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }

        .square.check {
            background-color: var(--check-square);
        }
        
        .square.checkmate {
            background-color: var(--checkmate-square);
            animation: pulse 1s infinite;
        }

        .square.giving-check {
            background-color: #FFA07A;
            box-shadow: 0 0 10px #FFA07A;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="back-button" onclick="goBack()">
            <i class="fas fa-arrow-left"></i>
            Back to Menu
        </button>

        <div class="welcome-message">
            <h2>Welcome to Online Chess</h2>
            <p>Experience a refined chess game with elegant visuals and smooth gameplay. Click the "Start Game" button to begin playing.</p>
        </div>

        <div id="game-status" class="hidden">Waiting for opponent...</div>

        <div class="game-container hidden">
            <div class="side-panel">
                <div class="captured-pieces" id="black-captured">
                    <!-- Black captured pieces will appear here -->
                </div>
                <div class="player-panel">
                    <div class="player-info">
                        <div class="turn-indicator" id="player2-indicator"></div>
                        <span class="player-name" id="player2-name">Player 2</span>
                    </div>
                    <!-- <span class="player-time" id="player2-time">10:00</span> -->
                </div>
            </div>

            <div id="game-info">
                <div id="chess-board">
                    <!-- Board will be created dynamically -->
                    <!-- Rank and file labels will be added here -->
                </div>
            </div>

            <div class="side-panel">
                <div class="captured-pieces" id="white-captured">
                    <!-- White captured pieces will appear here -->
                </div>
                <div class="player-panel">
                    <div class="player-info">
                        <div class="turn-indicator" id="player1-indicator"></div>
                        <span class="player-name" id="player1-name">Player 1</span>
                    </div>
                    <!-- <span class="player-time" id="player1-time">10:00</span> -->
                </div>
            </div>
        </div>

        <div id="controls">
            <button id="start-game">Start Game</button>
            <button id="exit-game">Exit Game</button>
        </div>
    </div>

    <script>
        function goBack() {
            // Close WebSocket connection if it exists
            if (socket) {
                socket.close(1000, "User returning to menu");
            }
            // Go back to the main menu
            window.location.href = 'index.html';
        }

        // Server configuration
        const SERVER_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
            ? 'ws://localhost:8080'  // Local development
            : `wss://${window.location.hostname}/ws`;  // Production with ngrok

        let token = 'test-token-' + Math.random().toString(36).substring(7);
        let socket = null;
        let gameStarted = false;
        let playerRole = null;
        let isMyTurn = false;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        let isConnecting = false;
        let reconnectTimeout = null;

        // Add chess piece image paths
        const PIECES = {
            'white': {
                'king': 'images/white_king.png',
                'queen': 'images/white_queen.png',
                'rook': 'images/white_rook.png',
                'bishop': 'images/white_bishop.png',
                'knight': 'images/white_knight.png',
                'pawn': 'images/white_pawn.png'
            },
            'black': {
                'king': 'images/black_king.png',
                'queen': 'images/black_queen.png',
                'rook': 'images/black_rook.png',
                'bishop': 'images/black_bishop.png',
                'knight': 'images/black_knight.png',
                'pawn': 'images/black_pawn.png'
            }
        };

        // Initialize the board state
        let boardState = {
            pieces: {},
            selectedPiece: null,
            validMoves: []
        };

        // Initialize chess.js game
        let game = new Chess();

        function connectWebSocket() {
            if (isConnecting) {
                console.log("Already attempting to connect...");
                return;
            }

            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("WebSocket already connected");
                return;
            }

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            isConnecting = true;
            console.log("Connecting to WebSocket server with token:", token);
            
            try {
                // Use the appropriate WebSocket URL based on environment
                const wsUrl = `${SERVER_URL}?token=${encodeURIComponent(token)}`;
                console.log(`Connecting to: ${wsUrl}`);
                socket = new WebSocket(wsUrl);
                
                // Add these headers for ngrok compatibility
                socket.onopen = function () {
                    console.log("Connected to server successfully");
                    isConnecting = false;
                    reconnectAttempts = 0;
                    gameStarted = false;
                    // Request to join a game
                    socket.send(JSON.stringify({ type: "JOIN_GAME" }));
                };

                socket.onclose = function (event) {
                    console.log("WebSocket connection closed:", {
                        code: event.code,
                        reason: event.reason,
                        wasClean: event.wasClean
                    });
                    
                    isConnecting = false;
                    // Only attempt to reconnect if it wasn't a clean closure
                    if (event.code !== 1000 && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                        reconnectTimeout = setTimeout(connectWebSocket, 3000);
                    } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                        console.log("Max reconnection attempts reached. Please refresh the page.");
                    }
                };

                socket.onerror = function (error) {
                    console.error("WebSocket error:", error);
                    isConnecting = false;
                };

                socket.onmessage = function (event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log("Message from server:", message);

                        switch (message.type) {
                            case "CONNECTION_SUCCESS":
                                console.log("Connection established successfully");
                                break;
                            case "GAME_ASSIGNED":
                                playerRole = message.role;
                                if (playerRole === "white") {
                                    document.getElementById("player1-name").textContent = "You (White)";
                                    document.getElementById("player2-name").textContent = "Opponent (Black)";
                                } else {
                                    document.getElementById("player1-name").textContent = "Opponent (White)";
                                    document.getElementById("player2-name").textContent = "You (Black)";
                                }
                                isMyTurn = playerRole === "white";
                                break;
                            case "INIT_GAME":
                                createChessboard();
                                break;
                            case "INIT_GAME_ACK":
                                console.log("Game initialization acknowledged");
                                break;
                            case "MOVE":
                                console.log("Move received:", message.move);
                                updateBoard(message.move);
                                // Update turn based on the move's role
                                isMyTurn = (message.role !== playerRole);
                                console.log("Turn updated:", {
                                    isMyTurn: isMyTurn,
                                    messageRole: message.role,
                                    playerRole: playerRole
                                });
                                break;
                            case "GAME_OVER":
                                console.log("Game over received:", message);
                                gameStarted = false;
                                alert(message.message);
                                // Reset the game state
                                game = new Chess();
                                createChessboard();
                                document.querySelector('.game-container').classList.add('hidden');
                                document.querySelector('.welcome-message').classList.remove('hidden');
                                break;
                            case "GAME_JOINED":
                                console.log("Joined game");
                                gameStarted = true;
                                break;
                            case "EXIT_GAME":
                                alert("Game exited");
                                gameStarted = false;
                                break;
                            case "error":
                                console.error("Server error:", message.message);
                                break;
                            default:
                                console.log("Unknown message type");
                        }
                    } catch (error) {
                        console.error("Error processing message:", error);
                    }
                };
            } catch (error) {
                console.error("Error creating WebSocket:", error);
                isConnecting = false;
            }
        }

        // Initialize Chessboard
        function createChessboard() {
            const board = document.getElementById("chess-board");
            board.innerHTML = "";

            const files = "abcdefgh";
            const ranks = "87654321";

            // Initialize the board state
            boardState.pieces = {};
            game.reset(); // Reset the chess.js game

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement("div");
                    square.classList.add("square", (i + j) % 2 === 0 ? "light" : "dark");
                    square.dataset.position = `${files[j]}${ranks[i]}`;
                    
                    // Add click handler for moves
                    square.addEventListener("click", () => {
                        if (isMyTurn && gameStarted) {
                            handleSquareClick(square);
                        }
                    });
                    
                    board.appendChild(square);
                }
            }

            // Set up initial piece positions
            setupInitialPosition();
        }

        function setupInitialPosition() {
            const initialPosition = {
                'a8': { type: 'rook', color: 'black' },
                'b8': { type: 'knight', color: 'black' },
                'c8': { type: 'bishop', color: 'black' },
                'd8': { type: 'queen', color: 'black' },
                'e8': { type: 'king', color: 'black' },
                'f8': { type: 'bishop', color: 'black' },
                'g8': { type: 'knight', color: 'black' },
                'h8': { type: 'rook', color: 'black' },
                'a7': { type: 'pawn', color: 'black' },
                'b7': { type: 'pawn', color: 'black' },
                'c7': { type: 'pawn', color: 'black' },
                'd7': { type: 'pawn', color: 'black' },
                'e7': { type: 'pawn', color: 'black' },
                'f7': { type: 'pawn', color: 'black' },
                'g7': { type: 'pawn', color: 'black' },
                'h7': { type: 'pawn', color: 'black' },
                'a2': { type: 'pawn', color: 'white' },
                'b2': { type: 'pawn', color: 'white' },
                'c2': { type: 'pawn', color: 'white' },
                'd2': { type: 'pawn', color: 'white' },
                'e2': { type: 'pawn', color: 'white' },
                'f2': { type: 'pawn', color: 'white' },
                'g2': { type: 'pawn', color: 'white' },
                'h2': { type: 'pawn', color: 'white' },
                'a1': { type: 'rook', color: 'white' },
                'b1': { type: 'knight', color: 'white' },
                'c1': { type: 'bishop', color: 'white' },
                'd1': { type: 'queen', color: 'white' },
                'e1': { type: 'king', color: 'white' },
                'f1': { type: 'bishop', color: 'white' },
                'g1': { type: 'knight', color: 'white' },
                'h1': { type: 'rook', color: 'white' }
            };

            // Place pieces on the board
            for (const [position, piece] of Object.entries(initialPosition)) {
                const square = document.querySelector(`[data-position="${position}"]`);
                if (square) {
                    const img = document.createElement('img');
                    img.src = PIECES[piece.color][piece.type];
                    img.alt = `${piece.color} ${piece.type}`;
                    square.appendChild(img);
                    boardState.pieces[position] = piece;
                }
            }
        }

        function handleSquareClick(square) {
            const position = square.dataset.position;
            if (!position) return;

            if (!boardState.selectedPiece) {
                // Select a piece
                const piece = boardState.pieces[position];
                if (piece && piece.color === (playerRole === 'white' ? 'white' : 'black')) {
                    boardState.selectedPiece = position;
                    square.classList.add('selected');
                    highlightValidMoves(position);
                }
            } else {
                // Move the selected piece
                const fromPosition = boardState.selectedPiece;
                const toPosition = position;
                
                // Check if the move is valid using chess.js
                const move = game.move({
                    from: fromPosition,
                    to: toPosition,
                    promotion: 'q' // Always promote to queen for simplicity
                });
                
                if (move) {
                    // Check if a piece is being captured
                    const capturedPiece = boardState.pieces[toPosition];
                    if (capturedPiece) {
                        movePieceToCaptured(capturedPiece, toPosition);
                    }

                    // Move is valid, update the board
                    boardState.pieces[toPosition] = boardState.pieces[fromPosition];
                    delete boardState.pieces[fromPosition];
                    
                    // Update the display
                    const fromSquare = document.querySelector(`[data-position="${fromPosition}"]`);
                    const toSquare = document.querySelector(`[data-position="${toPosition}"]`);
                    const pieceImg = fromSquare.querySelector('img');
                    if (pieceImg) {
                        toSquare.appendChild(pieceImg);
                    }
                    
                    // Clear selection and valid move highlights
                    fromSquare.classList.remove('selected');
                    clearValidMoveHighlights();
                    boardState.selectedPiece = null;
                    
                    // Send move to server
                    sendMove({
                        from: fromPosition,
                        to: toPosition
                    });
                    
                    // Update turn indicator
                    isMyTurn = false;
                    updateTurnIndicator();

                    // Update check status immediately after making the move
                    updateCheckStatus();
                } else {
                    // Invalid move, clear selection
                    const fromSquare = document.querySelector(`[data-position="${fromPosition}"]`);
                    fromSquare.classList.remove('selected');
                    clearValidMoveHighlights();
                    boardState.selectedPiece = null;
                }
            }
        }

        function highlightValidMoves(position) {
            const moves = game.moves({ square: position, verbose: true });
            moves.forEach(move => {
                const square = document.querySelector(`[data-position="${move.to}"]`);
                if (square) {
                    square.classList.add('valid-move');
                }
            });
        }

        function clearValidMoveHighlights() {
            document.querySelectorAll('.valid-move').forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        // Modify the DOMContentLoaded event listener
        document.addEventListener("DOMContentLoaded", () => {
            createChessboard();
            
            // Hide the game board initially
            document.querySelector('.game-container').classList.add('hidden');
        });

        function sendMove(move) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ 
                    type: "MOVE", 
                    move: move,
                    role: playerRole
                }));
            } else {
                console.error("WebSocket is not open. Current state:", socket ? socket.readyState : "No socket");
                // Attempt to reconnect if the connection is lost
                if (!isConnecting) {
                    connectWebSocket();
                }
            }
        }

        // Modify the start game button event listener
        document.getElementById("start-game").addEventListener("click", () => {
            // Hide welcome message
            document.querySelector('.welcome-message').classList.add('hidden');
            
            // Show the game board
            document.querySelector('.game-container').classList.remove('hidden');
            
            // Connect to the server if not already connected
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                connectWebSocket();
            } else {
                // If already connected, just start the game
                console.log("Starting game...");
                socket.send(JSON.stringify({ type: "INIT_GAME" }));
                gameStarted = true;
            }
        });

        document.getElementById("exit-game").addEventListener("click", () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("Exiting game...");
                socket.send(JSON.stringify({ type: "EXIT_GAME" }));
                gameStarted = false;
                playerRole = null;
                isMyTurn = false;
                alert("Exited Game");
            } else {
                console.log("Cannot exit game:", {
                    socketState: socket ? socket.readyState : "No socket"
                });
                // Attempt to reconnect if the connection is lost
                if (!isConnecting && (!socket || socket.readyState !== WebSocket.OPEN)) {
                    connectWebSocket();
                }
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (socket) {
                socket.close(1000, "Page closing");
            }
        });

        function updateBoard(move) {
            if (!move || !move.from || !move.to) return;
            
            // Update chess.js game
            const chessMove = game.move({
                from: move.from,
                to: move.to,
                promotion: 'q'
            });
            
            if (!chessMove) return;
            
            const fromSquare = document.querySelector(`[data-position="${move.from}"]`);
            const toSquare = document.querySelector(`[data-position="${move.to}"]`);
            
            if (fromSquare && toSquare) {
                // Check if a piece is being captured
                const capturedPiece = boardState.pieces[move.to];
                if (capturedPiece) {
                    movePieceToCaptured(capturedPiece, move.to);
                }

                // Get the piece from the source square
                const piece = boardState.pieces[move.from];
                
                // Update the display
                const pieceImg = fromSquare.querySelector('img');
                if (pieceImg) {
                    toSquare.appendChild(pieceImg);
                }
                
                // Update board state
                boardState.pieces[move.to] = piece;
                delete boardState.pieces[move.from];
                
                // Handle special moves (castling, en passant, pawn promotion)
                if (chessMove.flags.includes('k') || chessMove.flags.includes('q')) {
                    // Handle castling
                    const rookFrom = chessMove.flags.includes('k') ? 'h' : 'a';
                    const rookTo = chessMove.flags.includes('k') ? 'f' : 'd';
                    const rank = move.from[1];
                    
                    const rookFromSquare = document.querySelector(`[data-position="${rookFrom}${rank}"]`);
                    const rookToSquare = document.querySelector(`[data-position="${rookTo}${rank}"]`);
                    
                    if (rookFromSquare && rookToSquare) {
                        const rookImg = rookFromSquare.querySelector('img');
                        if (rookImg) {
                            rookToSquare.appendChild(rookImg);
                        }
                        
                        // Update board state for rook
                        boardState.pieces[`${rookTo}${rank}`] = boardState.pieces[`${rookFrom}${rank}`];
                        delete boardState.pieces[`${rookFrom}${rank}`];
                    }
                } else if (chessMove.flags.includes('e')) {
                    // Handle en passant
                    const capturedPawnSquare = document.querySelector(`[data-position="${move.to[0]}${move.from[1]}"]`);
                    if (capturedPawnSquare) {
                        const capturedPiece = boardState.pieces[`${move.to[0]}${move.from[1]}`];
                        if (capturedPiece) {
                            movePieceToCaptured(capturedPiece, `${move.to[0]}${move.from[1]}`);
                        }
                        delete boardState.pieces[`${move.to[0]}${move.from[1]}`];
                    }
                }

                // Check for check and checkmate
                updateCheckStatus();
            }
        }

        function updateCheckStatus() {
            // Remove any existing check highlights
            document.querySelectorAll('.square.check, .square.checkmate, .square.giving-check').forEach(square => {
                square.classList.remove('check', 'checkmate', 'giving-check');
            });

            // Check if the game is in check or checkmate
            if (game.in_check()) {
                // Get the color of the king that is in check (the one whose turn it is)
                const kingColor = game.turn() === 'w' ? 'white' : 'black';
                const kingPosition = findKingPosition(kingColor);
                if (kingPosition) {
                    // Highlight the king in check
                    const kingSquare = document.querySelector(`[data-position="${kingPosition}"]`);
                    if (kingSquare) {
                        kingSquare.classList.add('check');
                    }

                    // Find and highlight the piece giving check
                    const checkingPiecePosition = findCheckingPiece(kingPosition, kingColor);
                    if (checkingPiecePosition) {
                        const checkingPieceSquare = document.querySelector(`[data-position="${checkingPiecePosition}"]`);
                        if (checkingPieceSquare) {
                            checkingPieceSquare.classList.add('giving-check');
                        }
                    }
                }
            }

            if (game.in_checkmate()) {
                // Get the color of the king that is in checkmate (the one whose turn it is)
                const kingColor = game.turn() === 'w' ? 'white' : 'black';
                const kingPosition = findKingPosition(kingColor);
                if (kingPosition) {
                    const kingSquare = document.querySelector(`[data-position="${kingPosition}"]`);
                    if (kingSquare) {
                        kingSquare.classList.add('checkmate');
                    }

                    // Find and highlight the piece giving checkmate
                    const checkingPiecePosition = findCheckingPiece(kingPosition, kingColor);
                    if (checkingPiecePosition) {
                        const checkingPieceSquare = document.querySelector(`[data-position="${checkingPiecePosition}"]`);
                        if (checkingPieceSquare) {
                            checkingPieceSquare.classList.add('giving-check');
                        }
                    }
                }
                // Show game over message
                const winner = game.turn() === 'w' ? 'Black' : 'White';
                setTimeout(() => {
                    alert(`Checkmate! ${winner} wins!`);
                    gameStarted = false;
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ 
                            type: "GAME_OVER",
                            winner: winner
                        }));
                    }
                }, 500);
            } else if (game.in_draw()) {
                setTimeout(() => {
                    alert("Game ended in a draw!");
                    gameStarted = false;
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ 
                            type: "GAME_OVER",
                            result: "draw"
                        }));
                    }
                }, 500);
            }
        }

        function findCheckingPiece(kingPosition, kingColor) {
            const board = game.board();
            const kingFile = kingPosition.charCodeAt(0) - 97; // Convert a-h to 0-7
            const kingRank = 8 - parseInt(kingPosition[1]);   // Convert 1-8 to 0-7

            // Check all squares on the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece && piece.color !== (kingColor === 'white' ? 'w' : 'b')) {
                        // Try to move the piece to the king's position
                        const fromFile = String.fromCharCode(97 + j);
                        const fromRank = 8 - i;
                        const fromPosition = `${fromFile}${fromRank}`;
                        
                        const move = game.move({
                            from: fromPosition,
                            to: kingPosition,
                            promotion: 'q'
                        });
                        
                        // If the move is valid, this piece is giving check
                        if (move) {
                            game.undo(); // Undo the move
                            return fromPosition;
                        }
                    }
                }
            }
            return null;
        }

        function findKingPosition(color) {
            const board = game.board();
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece && piece.type === 'k' && piece.color === (color === 'white' ? 'w' : 'b')) {
                        const file = String.fromCharCode(97 + j);
                        const rank = 8 - i;
                        return `${file}${rank}`;
                    }
                }
            }
            return null;
        }

        function movePieceToCaptured(piece, position) {
            const capturedContainer = piece.color === 'white' ? 
                document.getElementById('white-captured') : 
                document.getElementById('black-captured');
            
            const capturedPieceDiv = document.createElement('div');
            capturedPieceDiv.className = 'captured-piece';
            
            const img = document.createElement('img');
            img.src = PIECES[piece.color][piece.type];
            img.alt = `${piece.color} ${piece.type}`;
            
            capturedPieceDiv.appendChild(img);
            capturedContainer.appendChild(capturedPieceDiv);
            
            // Remove the piece from the board
            const square = document.querySelector(`[data-position="${position}"]`);
            const pieceImg = square.querySelector('img');
            if (pieceImg) {
                pieceImg.remove();
            }
        }

        function updateTurnIndicator() {
            const player1Indicator = document.getElementById('player1-indicator');
            const player2Indicator = document.getElementById('player2-indicator');
            
            if (playerRole === 'white') {
                player1Indicator.classList.toggle('turn-active', isMyTurn);
                player2Indicator.classList.toggle('turn-active', !isMyTurn);
            } else {
                player1Indicator.classList.toggle('turn-active', !isMyTurn);
                player2Indicator.classList.toggle('turn-active', isMyTurn);
            }
        }
    </script>
</body>
</html>