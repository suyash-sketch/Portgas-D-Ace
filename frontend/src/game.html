<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body {
            background-color: #302e2b;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
        }

        .container {
            width: 80%;
            margin: auto;
        }

        .welcome-message {
            text-align: center;
            margin: 50px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            max-width: 600px;
        }

        .welcome-message h2 {
            color: #739552;
            margin-bottom: 20px;
        }

        .welcome-message p {
            font-size: 18px;
            line-height: 1.5;
        }

        .hidden {
            display: none;
        }

        #chess-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 2px;
            width: 400px;
            margin: 20px auto;
            border: 2px solid white;
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
        }

        .square img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .light {
            background-color: #EBECD0;
        }

        .dark {
            background-color: #739552;
        }

        #controls {
            margin-top: 20px;
        }

        button {
            padding: 10px;
            margin: 5px;
            background: #739552;
            color: white;
            border: none;
            cursor: pointer;
        }

        .square.selected {
            background-color: #baca44;
        }
        
        .square.valid-move {
            background-color: #f7f769;
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin: 20px auto;
            width: 80%;
        }

        .captured-pieces {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            min-width: 50px;
        }

        .captured-piece {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .captured-piece img {
            width: 30px;
            height: 30px;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Online Chess Game</h1>

        <div class="welcome-message">
            <h2>Welcome to Online Chess</h2>
            <p>Click the "Start Game" button to begin playing.</p>
        </div>

        <div class="game-container hidden">
            <div class="captured-pieces" id="black-captured"></div>
            <div id="game-info">
                <div id="player2">
                    <span id="player2-name">Player 2</span>
                    <span id="player2-time">10:00</span>
                </div>

                <div id="chess-board"></div>

                <div id="player1">
                    <span id="player1-name">Player 1</span>
                    <span id="player1-time">10:00</span>
                </div>
            </div>
            <div class="captured-pieces" id="white-captured"></div>
        </div>

        <div id="controls">
            <button id="start-game">Start Game</button>
            <button id="exit-game">Exit Game</button>
        </div>
    </div>

    <script>
        // Server configuration
        const SERVER_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
            ? 'ws://localhost:8080'  // Local development
            : `ws://${window.location.hostname}:8080/ws`;  // Production with explicit port and path
        let token = 'test-token-' + Math.random().toString(36).substring(7);
        let socket = null;
        let gameStarted = false;
        let playerRole = null;
        let isMyTurn = false;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        let isConnecting = false;
        let reconnectTimeout = null;

        // Add chess piece image paths
        const PIECES = {
            'white': {
                'king': 'images/white_king.jpg',
                'queen': 'images/white_queen.jpg',
                'rook': 'images/white_rook.jpg',
                'bishop': 'images/white_bishop.jpg',
                'knight': 'images/white_knight.jpg',
                'pawn': 'images/white_pawn.jpg'
            },
            'black': {
                'king': 'images/black_king.jpg',
                'queen': 'images/black_queen.jpg',
                'rook': 'images/black_rook.jpg',
                'bishop': 'images/black_bishop.jpg',
                'knight': 'images/black_knight.jpg',
                'pawn': 'images/black_pawn.jpg'
            }
        };

        // Initialize the board state
        let boardState = {
            pieces: {},
            selectedPiece: null,
            validMoves: []
        };

        // Initialize chess.js game
        let game = new Chess();

        function connectWebSocket() {
            if (isConnecting) {
                console.log("Already attempting to connect...");
                return;
            }

            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("WebSocket already connected");
                return;
            }

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            isConnecting = true;
            console.log("Connecting to WebSocket server with token:", token);
            
            try {
                // Use the appropriate WebSocket URL based on environment
                const wsUrl = `${SERVER_URL}?token=${encodeURIComponent(token)}`;
                console.log(`Connecting to: ${wsUrl}`);
                socket = new WebSocket(wsUrl);
                
                socket.onopen = function () {
                    console.log("Connected to server successfully");
                    isConnecting = false;
                    reconnectAttempts = 0;
                    gameStarted = false;
                    // Request to join a game
                    socket.send(JSON.stringify({ type: "JOIN_GAME" }));
                };

                socket.onclose = function (event) {
                    console.log("WebSocket connection closed:", {
                        code: event.code,
                        reason: event.reason,
                        wasClean: event.wasClean
                    });
                    
                    isConnecting = false;
                    // Only attempt to reconnect if it wasn't a clean closure
                    if (event.code !== 1000 && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                        reconnectTimeout = setTimeout(connectWebSocket, 3000);
                    } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                        console.log("Max reconnection attempts reached. Please refresh the page.");
                    }
                };

                socket.onerror = function (error) {
                    console.error("WebSocket error:", error);
                    isConnecting = false;
                };

                socket.onmessage = function (event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log("Message from server:", message);

                        switch (message.type) {
                            case "CONNECTION_SUCCESS":
                                console.log("Connection established successfully");
                                break;
                            case "GAME_ASSIGNED":
                                playerRole = message.role;
                                if (playerRole === "white") {
                                    document.getElementById("player1-name").textContent = "You (White)";
                                    document.getElementById("player2-name").textContent = "Opponent (Black)";
                                } else {
                                    document.getElementById("player1-name").textContent = "Opponent (White)";
                                    document.getElementById("player2-name").textContent = "You (Black)";
                                }
                                isMyTurn = playerRole === "white";
                                console.log(`Assigned role: ${playerRole}, isMyTurn: ${isMyTurn}`);
                                break;
                            case "INIT_GAME":
                                createChessboard();
                                break;
                            case "MOVE":
                                console.log("Move received:", {
                                    move: message.move,
                                    role: message.role,
                                    currentRole: playerRole,
                                    isMyTurn
                                });
                                // Update the board with the move
                                updateBoard(message.move);
                                // Only set isMyTurn to true if it's our role's turn
                                isMyTurn = (message.role === playerRole);
                                break;
                            case "GAME_OVER":
                                alert("Game Over!");
                                gameStarted = false;
                                break;
                            case "GAME_JOINED":
                                console.log("Joined game");
                                gameStarted = true;
                                break;
                            case "EXIT_GAME":
                                alert("Game exited");
                                gameStarted = false;
                                break;
                            case "error":
                                console.error("Server error:", message.message);
                                break;
                            default:
                                console.log("Unknown message type");
                        }
                    } catch (error) {
                        console.error("Error processing message:", error);
                    }
                };
            } catch (error) {
                console.error("Error creating WebSocket:", error);
                isConnecting = false;
            }
        }

        // Initialize Chessboard
        function createChessboard() {
            const board = document.getElementById("chess-board");
            board.innerHTML = "";

            const files = "abcdefgh";
            const ranks = "87654321";

            // Initialize the board state
            boardState.pieces = {};
            game.reset(); // Reset the chess.js game

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement("div");
                    square.classList.add("square", (i + j) % 2 === 0 ? "light" : "dark");
                    square.dataset.position = `${files[j]}${ranks[i]}`;
                    
                    // Add click handler for moves
                    square.addEventListener("click", () => {
                        if (isMyTurn && gameStarted) {
                            handleSquareClick(square);
                        }
                    });
                    
                    board.appendChild(square);
                }
            }

            // Set up initial piece positions
            setupInitialPosition();
        }

        function setupInitialPosition() {
            const initialPosition = {
                'a8': { type: 'rook', color: 'black' },
                'b8': { type: 'knight', color: 'black' },
                'c8': { type: 'bishop', color: 'black' },
                'd8': { type: 'queen', color: 'black' },
                'e8': { type: 'king', color: 'black' },
                'f8': { type: 'bishop', color: 'black' },
                'g8': { type: 'knight', color: 'black' },
                'h8': { type: 'rook', color: 'black' },
                'a7': { type: 'pawn', color: 'black' },
                'b7': { type: 'pawn', color: 'black' },
                'c7': { type: 'pawn', color: 'black' },
                'd7': { type: 'pawn', color: 'black' },
                'e7': { type: 'pawn', color: 'black' },
                'f7': { type: 'pawn', color: 'black' },
                'g7': { type: 'pawn', color: 'black' },
                'h7': { type: 'pawn', color: 'black' },
                'a2': { type: 'pawn', color: 'white' },
                'b2': { type: 'pawn', color: 'white' },
                'c2': { type: 'pawn', color: 'white' },
                'd2': { type: 'pawn', color: 'white' },
                'e2': { type: 'pawn', color: 'white' },
                'f2': { type: 'pawn', color: 'white' },
                'g2': { type: 'pawn', color: 'white' },
                'h2': { type: 'pawn', color: 'white' },
                'a1': { type: 'rook', color: 'white' },
                'b1': { type: 'knight', color: 'white' },
                'c1': { type: 'bishop', color: 'white' },
                'd1': { type: 'queen', color: 'white' },
                'e1': { type: 'king', color: 'white' },
                'f1': { type: 'bishop', color: 'white' },
                'g1': { type: 'knight', color: 'white' },
                'h1': { type: 'rook', color: 'white' }
            };

            // Place pieces on the board
            for (const [position, piece] of Object.entries(initialPosition)) {
                const square = document.querySelector(`[data-position="${position}"]`);
                if (square) {
                    const img = document.createElement('img');
                    img.src = PIECES[piece.color][piece.type];
                    img.alt = `${piece.color} ${piece.type}`;
                    square.appendChild(img);
                    boardState.pieces[position] = piece;
                }
            }
        }

        function handleSquareClick(square) {
            const position = square.dataset.position;
            if (!position) return;

            if (!boardState.selectedPiece) {
                // Select a piece
                const piece = boardState.pieces[position];
                if (piece && piece.color === (playerRole === 'white' ? 'white' : 'black')) {
                    boardState.selectedPiece = position;
                    square.classList.add('selected');
                    highlightValidMoves(position);
                }
            } else {
                // Move the selected piece
                const fromPosition = boardState.selectedPiece;
                const toPosition = position;
                
                // Check if the move is valid using chess.js
                const move = game.move({
                    from: fromPosition,
                    to: toPosition,
                    promotion: 'q' // Always promote to queen for simplicity
                });
                
                if (move) {
                    // Check if a piece is being captured
                    const capturedPiece = boardState.pieces[toPosition];
                    if (capturedPiece) {
                        movePieceToCaptured(capturedPiece, toPosition);
                    }

                    // Move is valid, update the board
                    boardState.pieces[toPosition] = boardState.pieces[fromPosition];
                    delete boardState.pieces[fromPosition];
                    
                    // Update the display
                    const fromSquare = document.querySelector(`[data-position="${fromPosition}"]`);
                    const toSquare = document.querySelector(`[data-position="${toPosition}"]`);
                    const pieceImg = fromSquare.querySelector('img');
                    if (pieceImg) {
                        toSquare.appendChild(pieceImg);
                    }
                    
                    // Clear selection and valid move highlights
                    fromSquare.classList.remove('selected');
                    clearValidMoveHighlights();
                    boardState.selectedPiece = null;
                    
                    // Send move to server
                    sendMove({
                        from: fromPosition,
                        to: toPosition
                    });
                    
                    isMyTurn = false;
                } else {
                    // Invalid move, clear selection
                    const fromSquare = document.querySelector(`[data-position="${fromPosition}"]`);
                    fromSquare.classList.remove('selected');
                    clearValidMoveHighlights();
                    boardState.selectedPiece = null;
                }
            }
        }

        function highlightValidMoves(position) {
            const moves = game.moves({ square: position, verbose: true });
            moves.forEach(move => {
                const square = document.querySelector(`[data-position="${move.to}"]`);
                if (square) {
                    square.classList.add('valid-move');
                }
            });
        }

        function clearValidMoveHighlights() {
            document.querySelectorAll('.valid-move').forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        // Modify the DOMContentLoaded event listener
        document.addEventListener("DOMContentLoaded", () => {
            createChessboard();
            
            // Hide the game board initially
            document.querySelector('.game-container').classList.add('hidden');
        });

        function sendMove(move) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ 
                    type: "MOVE", 
                    move: move,
                    role: playerRole
                }));
            } else {
                console.error("WebSocket is not open. Current state:", socket ? socket.readyState : "No socket");
                // Attempt to reconnect if the connection is lost
                if (!isConnecting) {
                    connectWebSocket();
                }
            }
        }

        // Modify the start game button event listener
        document.getElementById("start-game").addEventListener("click", () => {
            // Hide welcome message
            document.querySelector('.welcome-message').classList.add('hidden');
            
            // Show the game board
            document.querySelector('.game-container').classList.remove('hidden');
            
            // Connect to the server if not already connected
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                connectWebSocket();
            } else {
                // If already connected, just start the game
                console.log("Starting game...");
                socket.send(JSON.stringify({ type: "INIT_GAME" }));
                gameStarted = true;
            }
        });

        document.getElementById("exit-game").addEventListener("click", () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("Exiting game...");
                socket.send(JSON.stringify({ type: "EXIT_GAME" }));
                gameStarted = false;
                playerRole = null;
                isMyTurn = false;
                alert("Exited Game");
            } else {
                console.log("Cannot exit game:", {
                    socketState: socket ? socket.readyState : "No socket"
                });
                // Attempt to reconnect if the connection is lost
                if (!isConnecting && (!socket || socket.readyState !== WebSocket.OPEN)) {
                    connectWebSocket();
                }
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (socket) {
                socket.close(1000, "Page closing");
            }
        });

        function updateBoard(move) {
            if (!move || !move.from || !move.to) return;
            
            // Update chess.js game
            const chessMove = game.move({
                from: move.from,
                to: move.to,
                promotion: 'q'
            });
            
            if (!chessMove) return;
            
            const fromSquare = document.querySelector(`[data-position="${move.from}"]`);
            const toSquare = document.querySelector(`[data-position="${move.to}"]`);
            
            if (fromSquare && toSquare) {
                // Check if a piece is being captured
                const capturedPiece = boardState.pieces[move.to];
                if (capturedPiece) {
                    movePieceToCaptured(capturedPiece, move.to);
                }

                // Get the piece from the source square
                const piece = boardState.pieces[move.from];
                
                // Update the display
                const pieceImg = fromSquare.querySelector('img');
                if (pieceImg) {
                    toSquare.appendChild(pieceImg);
                }
                
                // Update board state
                boardState.pieces[move.to] = piece;
                delete boardState.pieces[move.from];
                
                // Handle special moves (castling, en passant, pawn promotion)
                if (chessMove.flags.includes('k') || chessMove.flags.includes('q')) {
                    // Handle castling
                    const rookFrom = chessMove.flags.includes('k') ? 'h' : 'a';
                    const rookTo = chessMove.flags.includes('k') ? 'f' : 'd';
                    const rank = move.from[1];
                    
                    const rookFromSquare = document.querySelector(`[data-position="${rookFrom}${rank}"]`);
                    const rookToSquare = document.querySelector(`[data-position="${rookTo}${rank}"]`);
                    
                    if (rookFromSquare && rookToSquare) {
                        const rookImg = rookFromSquare.querySelector('img');
                        if (rookImg) {
                            rookToSquare.appendChild(rookImg);
                        }
                        
                        // Update board state for rook
                        boardState.pieces[`${rookTo}${rank}`] = boardState.pieces[`${rookFrom}${rank}`];
                        delete boardState.pieces[`${rookFrom}${rank}`];
                    }
                } else if (chessMove.flags.includes('e')) {
                    // Handle en passant
                    const capturedPawnSquare = document.querySelector(`[data-position="${move.to[0]}${move.from[1]}"]`);
                    if (capturedPawnSquare) {
                        const capturedPiece = boardState.pieces[`${move.to[0]}${move.from[1]}`];
                        if (capturedPiece) {
                            movePieceToCaptured(capturedPiece, `${move.to[0]}${move.from[1]}`);
                        }
                        delete boardState.pieces[`${move.to[0]}${move.from[1]}`];
                    }
                }
            }
        }

        function movePieceToCaptured(piece, position) {
            const capturedContainer = piece.color === 'white' ? 
                document.getElementById('white-captured') : 
                document.getElementById('black-captured');
            
            const capturedPieceDiv = document.createElement('div');
            capturedPieceDiv.className = 'captured-piece';
            
            const img = document.createElement('img');
            img.src = PIECES[piece.color][piece.type];
            img.alt = `${piece.color} ${piece.type}`;
            
            capturedPieceDiv.appendChild(img);
            capturedContainer.appendChild(capturedPieceDiv);
            
            // Remove the piece from the board
            const square = document.querySelector(`[data-position="${position}"]`);
            const pieceImg = square.querySelector('img');
            if (pieceImg) {
                pieceImg.remove();
            }
        }
    </script>
</body>
</html>